---
title: unsigned int
categories: [ "Variables" ]
subCategories: [ "자료형" ]
---





= unsigned int


// OVERVIEW SECTION STARTS
[#overview]
--

[float]
=== 설명
우노 그리고 다른 ATMEGA 기반 보드에서, unsigned int (부호없는 정수)는 2바이트 값을 저장하는 int와 똑같다. 그러나 음수를 저장하는 대신 양수(0 에서 65,535 (2^16) - 1)의 범위) 만 저장한다.

Due는 4 byte (32-bit)값(0에서 4,294,967,295 (2^32 - 1) 범위)을 저장한다.

unsigned int 와(부호있는) int의 차이는 가장 높은 비트(때때로 "sign" 비트로 참조되는 비트)를 해석하는 방법이다. 아두이노에서 int (부호 있음) 형에서, 높은 비트가 "1"이면, 그 수는 음스로 해성되고 다른 15비트는 (http://en.wikipedia.org/wiki/2%27s_complement[2's complement math])로 해석된다.
[%hardbreaks]

--
// OVERVIEW SECTION ENDS

[float]
=== 문법
`unsigned int var = val;`
`var` - unsigned int 변수 이름
`val` - 변수에 할당하는 값


// HOW TO USE SECTION STARTS
[#howtouse]
--

[float]
=== 예제 코드
// Describe what the example code is all about and add relevant code   ►►►►► THIS SECTION IS MANDATORY ◄◄◄◄◄


[source,arduino]
----
  unsigned int ledPin = 13;
----
[%hardbreaks]

[float]
=== 주의와 경고
부호없는 변수가 그 최대 용량을 넘으면 0으로 "roll over" 되면, 다른 경우는 아래와 같다:


[source,arduino]
----
unsigned int x;
   x = 0;
   x = x - 1;       // x 는 이제 65535 - 음의 방향 으로 roll over
   x = x + 1;       // x 는 이제 0 - rolls over
----

Math with unsigned variables may produce unexpected results, even if your unsigned variable never rolls over.

The MCU applies the following rules:

The calculation is done in the scope of the destination variable. E.g. if the destination variable is signed, it will do signed math, even if both input variables are unsigned.

However with a calculation which requires an intermediate result, the scope of the intermediate result is unspecified by the code. In this case, the MCU will do unsigned math for the intermediate result, because both inputs are unsigned!


[source,arduino]
----
unsigned int x=5;
unsigned int y=10;
int result;

   result = x - y; // 5 - 10 = -5, as expected
   result = (x - y)/2; // 5 - 10 in unsigned math is 65530!  65530/2 = 32765 
   
   // solution: use signed variables, or do the calculation step by step.
   result = x - y; // 5 - 10 = -5, as expected
   result = result / 2; //  -5/2 = -2 (only integer math, decimal places are dropped)
----
Why use unsigned variables at all?

- The rollover behaviour is desired, e.g. counters
- The signed variable is a bit too small, but you want to avoid the memory and speed loss of long/float.
--

--
// HOW TO USE SECTION ENDS


// SEE ALSO SECTION STARTS
[#see_also]
--

[float]
=== 더 볼 것

[role="language"]
* #LANGUAGE# link:../../constants/integerconstants[Integer Constants]

--
// SEE ALSO SECTION ENDS
